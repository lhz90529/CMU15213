## A Tour of Computer Syste
### 1.1 Information is Bits + Context
- **Computer System**
    - consists of _hardware_ and _system software_ that work together to run application programs

- **Hello Program**
    ```c
    //source file: hello.c
    #include <stdio.h>

    int main() {
        printf("hello world\n");
    }
    ```
    - Each character in the text file above is encoded by ASCII
        ```
        For example:
        # ---> 35
        i ---> 105
        n ---> 110
        c ---> 99
        l ---> 108
        and so on...
        Each integer is represent by 4 bytes (Each byte is 8 bits)
        Thus the source file stored in disk is a bunch of bits
        ```
        ![ASCII representation of hello.c](https://raw.githubusercontent.com/lhz90529/CMU15213/master/pics/ASCII%20representation%20of%20hello.PNG)

    - **One fundamental idea:**
        - All information in system including `disk files`, `programs stored in memory`, `user data stored in memory` and `data transferred across the network` is represented by a bunch of bits
        - The only thing that distinguishes different data objects is the context in which we view them
            > The same sequence of bytes might represent an `integer`, `floating point`, `chararcter`, `string` or `machine instruction`
    
### 1.2 Programs Are Translated by Other Program into Different Forms
- `hello.c` can be read and understand by _human_ but not by _system_
- C statements has to be transferred into low-level `machie-language` such that it can be executed
    ```bash
    unix> gcc -o hello hello.c
    ```
- The compilation system
    ```
            preprocessor            Compiler            Assembler           Linker
    hello.c ------------> hello.i   ----------> hello.s ----------> hello.o -------> Executable
                                                                    print.o
    ```
        
    | extension    |     *.c     |          *.i         |        *.s       |             *.o            |                           |
    |--------------|:-----------:|:--------------------:|:----------------:|:--------------------------:|:-------------------------:|
    | generated by | human       | preprocessor         | compiler         | assembler                  |           linker          |
    | description  | source file | modified source file | assembly program | relocatable object program | executable object file    |
    | format       |     text    |         text         |       text       |           binary           |           binary          |
    - _Preprocessing phase_
        - Preprocessor modifies original C program by insert all directives begin with **#**
        ```c
        For example, 
        #include <stdio.h> tells the preprocessor to read the system header files stdio.h and insert it directly into the program text
        ```
        - generates a file with extension `.i`
    - _Compilation Phase_
        - Compiler takes the `hello.i` file and convert it into `hello.s` which contains `assembly language`
        - Each statement in an assembly language exactly describes `one low-level machine instruction`
        - generates a file with extension `.s`
    - _Assembly phase_
        - Assembler translates hello.s into `machine instruction`, and packages these `machine instruction` in a form called `relocatable object files`
        - generates files with extension `.o`
    - _Link phase_
        - Linker links all `.o` files into an `executable object file`
        - This `executable object file` is ready to load into memory and executed by system
    ```bash
    Get .i file: 
    gcc hello.c -E -o hello.i
    -E: stop after the prepocessing stage
    
    Get .s file:
    gcc hello.c -S

    Get .o file:
    gcc hello.c -c
    ```

- **The GNU Project**
- **GNU** is a project with the ambitious goal of  developing a complete _Unix-like_ system
- The **GNU** environment includes the `emacs editor`, `gcc compiler`, `gdb debugger`, `assembler`, `linker`, `utilities` for manipulating binaries, and other components. 

### 1.3 It Pays to Understand How Compilation Systems Work  
- programmer need to understand how compilation works to 
    - Optimizing program performance    ---> Chapter 3, 5, 6
    - Understanding link-time errors    ---> Chapter 7
    - Avoid security holes              ---> Chapter 3

### 1.4 Processors Read and Interpret Instructions Stored in Memory
- **Shell**
    - is `an application program`
    - is `command-line intepreter` that prints a prompt, waits for you to type a command line and then perform the command
    - If the first word of command line doesn't correspond to a built-in shell command, then the shell assume that it's the name of an executable file that it should load and run
- **Hardware Organization of a System**
![Hardware Organization](https://raw.githubusercontent.com/lhz90529/CMU15213/master/pics/Hardware%20Organization.PNG)

    - **Bus**
        - Carry bytes of information _back_ and _forth_ between components
        - Buses are typically designed to transfer **fixed-sized chunks of bytes** known as `words`
        - `word size` are generally either **`4-bytes`** or **`8-bytes`**
        - we assume that **`word size is 4-bytes`** and that bus transfer only _one word at a time_ 
    - **I/O Devices**
        - **I/o Devices** are the system's connection to `the external world`
            ```
            Example:
            keyboard and mouse: for user input
            display:            for user output
            disk:               in and out
            ```
        - `I/O Devices` is connected to `I/O bus` by `controller` or `adpater`
        - The purpose of either `controller` or `adpater` is to transfer information back and forth between the `I/O bus` and `I/O device`
    - **Main Memory**
        - a temporary storage device that holds both a program and the data it manipulates while the processor is executing the program.
        - _Physically,_ main memory consists of a collection of _dynamic random access memory_(**DRAM**)
    - **Processor**
        - short for _central processing unit_
        - is the `engine` that executes instructions stored in `main memory`
        - **At the core** is a word-sized storage device (**register**) called the **`program counter`**
            - At any time, **PC** point to some `machine instruction` in main memory
        - `Processor` will execute the instruction pointed by the `Program Counter` and updates `Program Counter` to point to _the next instrution_
        - **Execute one single instrution invole the following steps**
            - **read instruction** from `main memory` pointed by `program counter`
            - **interpret** the bits in the instruction
            - **perform some simple operation** dictated by the instruction
            - update the `program counter` to the next instruction
        - **Some simple operations**
            - **Load:** Copy a byte or a word from main memory into a register, overwriting the previous contents of the register
            - **Store:** Copy a byte or a word from a register to a location in main memory, overwriting the previous contents of that location
            - **Operate:** Copy the contents of two registers to the ALU, perform an arithmetic operation on the two words, and store the result in a register, overwriting the previous contents of that register.
            - **Jump:** : Extract a word from the instruction itself and copy that word into the program counter (PC), overwriting the previous value of the PC.



- **Running the `hello` Program**
    - `instruction` and `data` will be copied into main memory from disk
    - once all info has been load into `main memory`, the `processor` begins to execute the `machine instructions`

### 1.5 Caches Matter

![Cache](https://raw.githubusercontent.com/lhz90529/CMU15213/master/pics/Cache.PNG)
> if we take a closer look, we will find that we spend lot of time moving information
    
**For example:**
`machine instruction` in `hello` is first moved from `disk` to `main memory`, then moved from `main memory` to `processor`

**Similarly,** 
`data: hello world\n` is moved from `disk` to `main memory`, and then moved to `display`

- **Speed** of read data from `register` is much faster then from `main memory` and much much faster than from `disk`
    > register >> main memory >> disk
    
- Cache is a temporary storage which stores the information that the processor is likely need in the future, thus avoid to read from main memory or disk
- Cache exploit the concept **`Locality`**
    > An application programmers who are aware of cache memories can exploit them to improve the performance of their programs by **an order of magnitude**

### 1.6 Storage Devices From Hierachy
![Memory Hierachy](https://raw.githubusercontent.com/lhz90529/CMU15213/master/pics/memory%20hierarchy.PNG)
<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?L_i&space;\texttt{&space;a&space;cache&space;of&space;}&space;L_{i&space;&plus;&space;1}">
</p>


### 1.7 The Operating System Manages the Hardware
> Back to our hello example. When the shell loaded and ran the hello program, and when the hello program printed its message, **neither program accessed the keyboard, display, disk, or main memory directly.** Rather, they relied on the services provided by the **`operating system`**

![OS](https://raw.githubusercontent.com/lhz90529/CMU15213/master/pics/Operating%20System.PNG)


>_All attempts by an application program to manipulate the hardware must go through the operating system_

- The `operating system` has 2 primary purposes:
    1. protect hardware from misuse
    2. provide application with `simple`, `uniform` mechanism for manipulating `complicated` and `various` low-level hardware devices
- These goal are achieved via **the following 3 fundamental abstractions**
    1. ***processes:*** abstraction of `processor`, `main memory` and `I/O` 
    2. ***virtual memory:*** abstraction of `main memory` and `disk I/O devices`
    3. ***files:*** abstraction of `I/O`

    ![OS Abstractions](https://raw.githubusercontent.com/lhz90529/CMU15213/master/pics/OS%20Abstraction.PNG)

- **Process**
    - A _process_ is the operating system's abstraction of ***a running program***
    - Operating System provides the illusions for each `process` that
        - each process is **the only one running on the system**
        - each process has **exclusive use of `processor`, `main memory` and `I/O`**
        - each process will be executed by `processor` without `interruption`
    - Multicore processors can execute several processes _simultaneously_
    - singlecore processor can appear to execute multiple processes concurrently by **`context switching`**
        ```
        OS keep tracking of all state information that the process need to run
            save the context of current-running process
            load the context of a new process
            pass control to the new process
        ```
- **Threads**
    - a `process` consist of multiple execution units, called _`thread`_ eahc running in the context of `process` and sharing the same `code` and `global data`
    - **easier** to share data between `threads` than `processes`
- **Virtual Memory**
    - an abstraction that provides each process with the _illusion_ that it has ***exclusive use of the main memory***
    - Each process has **the same uniform view of memory**, which is known as its _virtual address space_
    ![virtual address space](https://raw.githubusercontent.com/lhz90529/CMU15213/master/pics/virtual%20address%20space.PNG)
    - `virtual address space` consists of following well-defined areas:
        - _Program code and data_
            - begins at the same fixed address for all processes
            - initialized directly from an executable object file
        - _Heap (run time)_
            - expand and shrink dynamically at run time as a result of `malloc` and `free`
        - _Shared libraries_
            - Chapter7
        - _Stack_
            - at the **top** of user's virtual address space 
            - expand and shrink dynamically at run time as a result of `function call`
        - _Kernal virtual memory_
            - always resident in memory
            - top of virtual address space is ***reserved for kernel***
            - application are not allowed to `read` or `write` to this area
- **Files**
    - is a sequence of byte, _nohting more and nothing less_
    - provides applications with a uniform view of `I/Os`
### 1.8 Systems Communicate with Other Systems Using Networks
- The `network` can be viewed as just another I/O device. 
![network](https://raw.githubusercontent.com/lhz90529/CMU15213/master/pics/network.PNG)
- The system copies sequence of bytes from main memory to `the network adapter`, then the data flows across the network to another machine
    ```
    Data flow:
                copied                   transferred
    main memory -------> network adapter ------------> another machine
    *******************************************************************
    A basic example: There are basically 5 steps involved if you want to run "hello" program on a remote server using "talnet"

    1: We type "hello" to the talent client and hit the enter key
    2: Client will send the string "hello" to remote server
    3: Sever receives the string "hello" and pass it to the shell which will run program "hello"
    4: Sever will send the output "hello world\n" back to Client
    5: Client receives the string "hello world\n" and display it
    ```
    ![run hello remotely](https://raw.githubusercontent.com/lhz90529/CMU15213/master/pics/Run%20hello%20remotely.PNG)

### 1.9 Important Themes

#### Concurrency and Parallelism
- **Thread-level Concurrency**
    ![different processor types](https://raw.githubusercontent.com/lhz90529/CMU15213/master/pics/different%20processor%20types.PNG)
- **Instruction-Level Parallelism**
    - modern processor can execute multiple instructions at one time, a property known as _instruction-level parallelism_

#### The importantce of Abstractions in Computer Systems
![abstraction](https://raw.githubusercontent.com/lhz90529/CMU15213/master/pics/abstraction.PNG)
- virtual machine is an abstraction of `the entire computer`